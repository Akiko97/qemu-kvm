#!/usr/bin/python

import curses
import sys, os, time, optparse

class DebugfsProvider(object):
    def __init__(self):
        self.base = '/sys/kernel/debug/kvm'
        self._fields = os.listdir(self.base)
    def fields(self):
        return self._fields
    def select(self, fields):
        self._fields = fields
    def read(self):
        def val(key):
            return int(file(self.base + '/' + key).read())
        return dict([(key, val(key)) for key in self._fields])

import ctypes, struct, array

libc = ctypes.CDLL('libc.so.6')
syscall = libc.syscall
class perf_event_attr(ctypes.Structure):
    _fields_ = [('type', ctypes.c_uint32),
                ('size', ctypes.c_uint32),
                ('config', ctypes.c_uint64),
                ('sample_freq', ctypes.c_uint64),
                ('sample_type', ctypes.c_uint64),
                ('read_format', ctypes.c_uint64),
                ('flags', ctypes.c_uint64),
                ('wakeup_events', ctypes.c_uint32),
                ('bp_type', ctypes.c_uint32),
                ('bp_addr', ctypes.c_uint64),
                ('bp_len', ctypes.c_uint64),
                ]
def _perf_event_open(attr, pid, cpu, group_fd, flags):
    return syscall(298, ctypes.pointer(attr), ctypes.c_int(pid),
                   ctypes.c_int(cpu), ctypes.c_int(group_fd),
                   ctypes.c_long(flags))

PERF_TYPE_HARDWARE			= 0
PERF_TYPE_SOFTWARE			= 1
PERF_TYPE_TRACEPOINT			= 2
PERF_TYPE_HW_CACHE			= 3
PERF_TYPE_RAW				= 4
PERF_TYPE_BREAKPOINT			= 5

PERF_SAMPLE_IP				= 1 << 0
PERF_SAMPLE_TID				= 1 << 1
PERF_SAMPLE_TIME			= 1 << 2
PERF_SAMPLE_ADDR			= 1 << 3
PERF_SAMPLE_READ			= 1 << 4
PERF_SAMPLE_CALLCHAIN			= 1 << 5
PERF_SAMPLE_ID				= 1 << 6
PERF_SAMPLE_CPU				= 1 << 7
PERF_SAMPLE_PERIOD			= 1 << 8
PERF_SAMPLE_STREAM_ID			= 1 << 9
PERF_SAMPLE_RAW				= 1 << 10

PERF_FORMAT_TOTAL_TIME_ENABLED		= 1 << 0
PERF_FORMAT_TOTAL_TIME_RUNNING		= 1 << 1
PERF_FORMAT_ID				= 1 << 2
PERF_FORMAT_GROUP			= 1 << 3


class TracepointProvider(object):
    def __init__(self):
        self.base = '/sys/kernel/debug/tracing/events/kvm/'
        fields = [f
                  for f in os.listdir(self.base)
                  if os.path.isdir(self.base + '/' + f)]
        self.select(fields)
    def fields(self):
        return self._fields
    def select(self, _fields):
        self._fields = _fields
        self.cpus = [0, 1]
        fds = []
        self.group_leaders = []
        for cpu in self.cpus:
            group_leader = -1
            for f in _fields:
                attr = perf_event_attr()
                attr.type = PERF_TYPE_TRACEPOINT
                attr.size = ctypes.sizeof(attr)
                id = int(file(self.base + f + '/id').read())
                attr.config = id
                attr.sample_type = (PERF_SAMPLE_RAW
                                    | PERF_SAMPLE_TIME
                                    | PERF_SAMPLE_CPU)
                attr.sample_period = 1
                attr.read_format = PERF_FORMAT_GROUP
                fd = _perf_event_open(attr, -1, cpu, group_leader, 0)
                if fd == -1:
                    raise Exception('perf_event_open failed')
                if group_leader == -1:
                    group_leader = fd
                    fds.append(fd)
            self.group_leaders.append(group_leader)
        self.fds = fds
        self.files = [os.fdopen(group_leader)
                      for group_leader in self.group_leaders]
    def read(self):
        ret = dict([(f, 0) for f in self._fields])
        bytes = 8 * (1 + len(self._fields))
        fmt = 'xxxxxxxx' + 'q' * len(self._fields)
        for file in self.files:
            a = struct.unpack(fmt, file.read(bytes))
            for field, val in zip(self._fields, a):
                ret[field] += val
        return ret

class Stats:
    def __init__(self, provider, fields = None):
        def wanted(key):
            import re
            if not fields:
                return True
            return re.match(fields, key) != None
        self.provider = provider
        self.values = dict([(key, None)
                            for key in provider.fields()
                            if wanted(key)])
        self.provider.select(self.values.keys())
    def get(self):
        new = self.provider.read()
        for key in self.provider.fields():
            oldval = self.values[key]
            newval = new[key]
            newdelta = None
            if oldval is not None:
                newdelta = newval - oldval[0]
            self.values[key] = (newval, newdelta)
        return self.values

if not os.access('/sys/kernel/debug', os.F_OK):
    print 'Please enable CONFIG_DEBUG_FS in your kernel'
    sys.exit(1)
if not os.access('/sys/kernel/debug/kvm', os.F_OK):
    print "Please mount debugfs ('mount -t debugfs debugfs /sys/kernel/debug')"
    print "and ensure the kvm modules are loaded"
    sys.exit(1)

label_width = 20
number_width = 10

def tui(screen, stats):
    curses.use_default_colors()
    curses.noecho()
    def refresh():
        screen.erase()
        screen.addstr(0, 0, 'kvm statistics')
        row = 2
        s = stats.get()
        for key in sorted(s.keys()):
            if row >= screen.getmaxyx()[0]:
                break
            values = s[key]
            col = 1
            screen.addstr(row, col, key)
            col += label_width
            screen.addstr(row, col, '%10d' % (values[0],))
            col += number_width
            if values[1] is not None:
                screen.addstr(row, col, '%8d' % (values[1],))
            row += 1
        screen.refresh()

    while True:
        refresh()
        curses.halfdelay(10)
        try:
            c = screen.getkey()
            if c == 'q':
                break
        except KeyboardInterrupt:
            break
        except curses.error:
            continue

def batch(stats):
    s = stats.get()
    time.sleep(1)
    s = stats.get()
    for key in sorted(s.keys()):
        values = s[key]
        print '%-22s%10d%10d' % (key, values[0], values[1])

def log(stats):
    keys = sorted(stats.get().iterkeys())
    def banner():
        for k in keys:
            print '%10s' % k[0:9],
        print
    def statline():
        s = stats.get()
        for k in keys:
            print ' %9d' % s[k][1],
        print
    line = 0
    banner_repeat = 20
    while True:
        time.sleep(1)
        if line % banner_repeat == 0:
            banner()
        statline()
        line += 1

options = optparse.OptionParser()
options.add_option('-1', '--once', '--batch',
                   action = 'store_true',
                   default = False,
                   dest = 'once',
                   help = 'run in batch mode for one second',
                   )
options.add_option('-l', '--log',
                   action = 'store_true',
                   default = False,
                   dest = 'log',
                   help = 'run in logging mode (like vmstat)',
                   )
options.add_option('-f', '--fields',
                   action = 'store',
                   default = None,
                   dest = 'fields',
                   help = 'fields to display (regex)',
                   )
(options, args) = options.parse_args(sys.argv)

try:
    provider = TracepointProvider()
except:
    provider = DebugfsProvider()

stats = Stats(provider, fields = options.fields)

if options.log:
    log(stats)
elif not options.once:
    import curses.wrapper
    curses.wrapper(tui, stats)
else:
    batch(stats)
